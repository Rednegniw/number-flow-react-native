---
title: Scrubbing Bridge
description: How worklet-driven scrubbing synchronizes JS and UI threads
full: true
---

The scrubbing system enables `SkiaNumberFlow` and `SkiaTimeFlow` to update at 120Hz on the UI thread when driven by a `SharedValue`, while still keeping React's JS-thread layout in sync.

## The problem

SharedValues live on the UI thread. React components re-render on the JS thread. When a SharedValue changes rapidly (gestures, animations), the JS thread can't keep up — creating a synchronization gap between the displayed value and React's component tree.

The component tree needs to know the **digit count** of the formatted string to allocate the right number of slots. But the formatted string changes on the UI thread faster than React can re-render.

## Architecture

### useScrubbingBridge

`useScrubbingBridge` monitors the SharedValue and periodically syncs key information back to the JS thread:

1. **Digit count extraction** — on the UI thread, the worklet reads the SharedValue string and counts digits. When the digit count changes (e.g. `"99"` → `"100"`), it signals the JS thread.

2. **Effective value** — the bridge provides an `effectiveValue` to the JS-thread formatting pipeline. For SharedValue mode, this is a representative number with the correct digit count, so React's layout computation allocates the right number of slots.

3. **Throttled sync** — not every SharedValue change triggers a JS update. Only structurally significant changes (digit count, sign change) cross the bridge.

### useScrubbingLayout

Once the JS thread has allocated the correct number of slots, `useScrubbingLayout` handles per-slot positioning on the UI thread:

1. **workletDigitValues** — an array of SharedValues, one per digit slot. A worklet reads the SharedValue string, parses each character, and writes the numeric digit value (0–9) to the corresponding SharedValue.

2. **workletLayout** — per-slot X positions computed from glyph metrics and the `scrubDigitWidthPercentile` setting.

3. **Width allocation** — during scrubbing, digit values change faster than glyph widths can animate. The `scrubDigitWidthPercentile` prop picks a fixed width between the narrowest and widest digit glyph:
   - `0.0` — narrowest digit width (tightest, may clip wide digits like "0")
   - `0.5` — average digit width
   - `0.75` (default) — 75th percentile, good balance
   - `1.0` — widest digit width (no clipping, but wider spacing)

### Data flow diagram

```
UI Thread                           JS Thread
─────────                           ─────────
SharedValue<string>
    ↓
useDerivedValue (format)
    ↓
worklet reads string
    ├─→ extracts digit values → workletDigitValues (SharedValue[])
    ├─→ counts digits
    │       ↓ (only on count change)
    │   ────bridge────→ effectiveValue
    │                       ↓
    │                   useNumberFormatting
    │                       ↓
    │                   computeKeyedLayout
    │                       ↓
    │                   renderSlots (allocate/deallocate)
    │                       ↓
    └─→ SkiaNumberFlow reads workletDigitValues
            ↓
        Skia renders digits at 120Hz
```

## Why this architecture

The key insight is separating **structural changes** (digit count) from **value changes** (which digit is displayed). Structural changes are rare — `"999"` → `"1000"` only happens at powers of 10. Value changes happen every frame during scrubbing.

By handling value changes entirely on the UI thread and only crossing the bridge for structural changes, the system achieves zero-latency rendering for the common case (same digit count, different digits) while still allowing React to manage the component tree.
