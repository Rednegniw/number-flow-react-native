---
title: Animation Pipeline
description: From value change to animated digits — the full rendering pipeline
full: true
---

This page traces the path from a value change to animated pixels on screen.

## Pipeline overview

```
value change
    ↓
useNumberFormatting / useTimeFormatting
    ↓  KeyedPart[]
computeKeyedLayout()
    ↓  LayoutEntry[]
useLayoutDiff()
    ↓  entering / exiting / updating
useFlowPipeline()
    ↓  resolved timing, trend, spin generations
renderSlots()
    ↓  DigitSlot / SymbolSlot components
useDigitAnimation() / useSlotOpacity()
    ↓  SharedValue-driven transforms
screen
```

## Formatting and layout

### Step 1: Formatting

`useNumberFormatting` takes the numeric value and produces an array of `KeyedPart` objects — each representing a single character with a stable key.

```tsx
// value=1234.56, format={ style: 'currency', currency: 'USD' }
// → KeyedPart[]: $, 1, ,, 2, 3, 4, ., 5, 6
//   keys: prefix:0, integer:3, group:0, integer:2, integer:1, integer:0, decimal:0, fraction:0, fraction:1
```

For `TimeFlow`, `useTimeFormatting` produces parts from hours/minutes/seconds with colon separators.

### Step 2: Layout

`computeKeyedLayout()` takes the keyed parts and glyph metrics to compute each character's X position, width, and whether it's a digit or symbol. Digits use `maxDigitWidth` (widest glyph among 0–9) for uniform slot sizing. Alignment is applied based on `textAlign` and container width.

### Step 3: Diffing

`useLayoutDiff()` compares the current layout with the previous one by key:

- **Entering** — new keys not in the previous layout → fade in + slide
- **Exiting** — old keys not in the current layout → fade out + slide
- **Updating** — same key in both → animate X position, possibly animate digit value

## Animation and rendering

### Step 4: Flow pipeline

`useFlowPipeline()` orchestrates the full animation:

1. **Timing resolution** — resolves `transformTiming`, `spinTiming`, `opacityTiming` with defaults (900ms deceleration, 450ms ease-out)
2. **Trend detection** — auto-detects spin direction from value change, or uses the provided `trend` prop/function
3. **Spin generation tracking** — increments a per-slot "generation" counter on each value change, used by digit slots to trigger new animations
4. **Continuous mode** — when enabled, computes additional full-rotation spin for unchanged lower digits
5. **Adaptive mask** — computes top/bottom mask heights from per-character glyph bounds (`charBounds`)
6. **Accessibility** — generates the formatted label and triggers announcements

### Step 5: Slot rendering

`renderSlots()` maps layout entries to `DigitSlot` and `SymbolSlot` components.

**DigitSlot** contains the virtual digit wheel. `useDigitAnimation()` drives a SharedValue representing the wheel's Y offset. When the target digit changes, the SharedValue animates from the current position to the new position using the resolved spin timing.

**SymbolSlot** renders static characters (decimal point, grouping separator, currency symbol). Entering/exiting symbols use opacity + translateY animations via `useSlotOpacity()`.

### Step 6: Masking

The gradient mask creates the signature edge fade:

- **Native** — When `@rednegniw/masked-view` is installed, the container is wrapped in a MaskedView with a stepped gradient mask element (transparent → opaque → transparent), providing smooth spatial fading at the edges. When the package isn't available, each digit computes its own opacity based on its signed scroll offset — as a digit approaches the container edge, its opacity fades from 1 → 0 over the mask zone. Both paths run inside the same worklet loop that positions digits, so fading is lock-step with scrolling.
- **Skia** — Two `LinearGradient` + `DstIn` blend layers compose horizontal and vertical fades. `final_alpha = content × h_alpha × v_alpha`.

The mask dimensions adapt to actual glyph bounds — taller characters get more mask headroom.
