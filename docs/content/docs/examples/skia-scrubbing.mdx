---
title: Skia Worklet Scrubbing
description: Zero-latency UI thread updates with SharedValue-driven scrubbing
full: true
---

The `sharedValue` prop on `SkiaNumberFlow` enables worklet-driven rendering — the number display updates entirely on the UI thread without crossing the JS bridge. This means updates at 120Hz with zero frame drops.

```LiveExample video=/videos/skia-scrubbing.mp4
import { View } from 'react-native';
import { Canvas } from '@shopify/react-native-skia';
import { useSharedValue, useAnimatedStyle, useDerivedValue } from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated from 'react-native-reanimated';
import { SkiaNumberFlow, useSkiaFont } from 'number-flow-react-native/skia';

const TRACK_WIDTH = 300;
const MIN = 0;
const MAX = 999.9;

export default function ScrubExample() {
  const thumbX = useSharedValue(TRACK_WIDTH / 2);
  const font = useSkiaFont('https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYMZg.ttf', 48);

  const formatted = useDerivedValue(() => {
    const ratio = Math.max(0, Math.min(1, thumbX.value / TRACK_WIDTH));
    const value = MIN + ratio * (MAX - MIN);
    return value.toFixed(1);
  });

  const pan = Gesture.Pan()
    .onBegin(({ x }) => { thumbX.value = Math.max(0, Math.min(TRACK_WIDTH, x)); })
    .onUpdate(({ x }) => { thumbX.value = Math.max(0, Math.min(TRACK_WIDTH, x)); });

  const fillStyle = useAnimatedStyle(() => ({ width: thumbX.value }));
  const thumbStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: thumbX.value - 18 }],
  }));

  return (
    <View style={{ alignItems: 'center', padding: 32, gap: 16 }}>
      <Canvas style={{ height: 60, width: TRACK_WIDTH }}>
        <SkiaNumberFlow
          sharedValue={formatted}
          font={font}
          suffix=" mg"
          color="#fff"
          y={48}
          width={TRACK_WIDTH}
          textAlign="center"
        />
      </Canvas>

      <GestureDetector gesture={pan}>
        <View style={{ width: TRACK_WIDTH, height: 48, justifyContent: 'center' }}>
          <View style={{ height: 8, width: TRACK_WIDTH, backgroundColor: 'rgba(255,255,255,0.15)', borderRadius: 4 }} />
          <Animated.View style={[{ position: 'absolute', height: 8, backgroundColor: '#fff', borderRadius: 4 }, fillStyle]} />
          <Animated.View style={[{ position: 'absolute', width: 36, height: 36, borderRadius: 18, backgroundColor: '#fff' }, thumbStyle]} />
        </View>
      </GestureDetector>
    </View>
  );
}
```

### How scrubbing works

1. You provide a `SharedValue<string>` — a pre-formatted string like `"50.0"` or `"$1,234.56"`.
2. On the UI thread, the worklet reads the string, extracts digits, and drives Skia rendering directly.
3. `useScrubbingBridge` periodically syncs the digit count back to the JS thread so React can update the layout (number of slots).
4. `useScrubbingLayout` computes per-slot positions from the worklet string.

<Callout type="info">
The `scrubDigitWidthPercentile` prop (default: `0.75`) controls how wide each digit slot is during scrubbing. Since digit values change rapidly during gestures, the component needs a fixed width per slot. The percentile picks a width between the narrowest (`0`) and widest (`1`) digit glyph.
</Callout>
